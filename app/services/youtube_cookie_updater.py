import os
import time
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.common.keys import Keys
from dotenv import load_dotenv
from pathlib import Path
import requests
from selenium.webdriver.common.action_chains import ActionChains

load_dotenv()

def save_cookies_netscape_format(driver, filename: str):
    """
    Guarda cookies en formato Netscape para yt-dlp y similares.
    """
    # Get cookies from both current domain and YouTube
    all_cookies = []
    
    # First get current domain cookies
    current_cookies = driver.get_cookies()
    all_cookies.extend(current_cookies)
    
    # Navigate to YouTube and get YouTube-specific cookies
    current_url = driver.current_url
    if "youtube.com" not in current_url:
        print("üîÑ Navegando a YouTube para obtener cookies espec√≠ficas...")
        driver.get("https://www.youtube.com")
        time.sleep(5)
        
        # Get YouTube cookies
        youtube_cookies = driver.get_cookies()
        
        # Add YouTube cookies if not already present
        existing_names = {c['name'] for c in all_cookies}
        for cookie in youtube_cookies:
            if cookie['name'] not in existing_names:
                all_cookies.append(cookie)
    
    # Also try to get cookies from YouTube Music for additional coverage
    try:
        print("üîÑ Obteniendo cookies de YouTube Music...")
        driver.get("https://music.youtube.com")
        time.sleep(3)
        music_cookies = driver.get_cookies()
        
        existing_names = {c['name'] for c in all_cookies}
        for cookie in music_cookies:
            if cookie['name'] not in existing_names:
                all_cookies.append(cookie)
    except:
        print("‚ö†Ô∏è No se pudieron obtener cookies de YouTube Music")
    
    # Write all cookies to file
    with open(filename, "w", encoding="utf-8") as f:
        f.write("# Netscape HTTP Cookie File\n")
        f.write("# This file is generated by YouTube Cookie Extractor. Do not edit.\n")
        
        # Sort cookies by domain for better organization
        all_cookies.sort(key=lambda x: x['domain'])
        
        for c in all_cookies:
            domain = c['domain']
            # Ensure domain starts with . for wildcard domains
            if not domain.startswith('.') and not domain.startswith('www.'):
                domain = '.' + domain
            
            flag = "TRUE" if domain.startswith(".") else "FALSE"
            path = c['path']
            secure = "TRUE" if c['secure'] else "FALSE"
            expiry = str(c.get('expiry', 0))
            name = c['name']
            value = c['value']
            
            line = f"{domain}\t{flag}\t{path}\t{secure}\t{expiry}\t{name}\t{value}\n"
            f.write(line)

def wait_for_human_verification(driver, max_wait=300):
    """
    Espera a que el usuario complete verificaciones manuales como CAPTCHA o 2FA
    """
    print("ü§ñ Detectando si hay verificaciones pendientes...")
    start_time = time.time()
    
    while time.time() - start_time < max_wait:
        current_url = driver.current_url.lower()
        page_source = driver.page_source.lower()
        
        # Check for various verification screens
        if any(keyword in current_url for keyword in ['challenge', 'verify', 'captcha']):
            print("üîí Verificaci√≥n detectada. Esperando intervenci√≥n manual...")
            print("‚è≥ Resuelve la verificaci√≥n en el navegador y el script continuar√° autom√°ticamente...")
            time.sleep(5)
            continue
        
        # Check if we're successfully logged in
        if "youtube.com" in current_url or "myaccount.google.com" in current_url:
            print("‚úÖ Verificaci√≥n completada exitosamente")
            return True
        
        time.sleep(2)
    
    return False

def comprehensive_youtube_login(email: str, password: str, output_path: str, headless: bool = False):
    """
    M√©todo m√°s completo y robusto para login en YouTube
    """
    chrome_options = Options()
    
    # Enhanced anti-detection measures
    chrome_options.add_argument("--disable-blink-features=AutomationControlled")
    chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
    chrome_options.add_experimental_option('useAutomationExtension', False)
    chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
    
    # Performance and stealth options
    chrome_options.add_argument("--disable-dev-shm-usage")
    chrome_options.add_argument("--disable-extensions")
    chrome_options.add_argument("--disable-plugins")
    chrome_options.add_argument("--disable-javascript-harmony-shipping")
    chrome_options.add_argument("--disable-background-timer-throttling")
    chrome_options.add_argument("--disable-backgrounding-occluded-windows")
    chrome_options.add_argument("--disable-renderer-backgrounding")
    chrome_options.add_argument("--disable-features=TranslateUI")
    chrome_options.add_argument("--disable-ipc-flooding-protection")
    chrome_options.add_argument("--no-first-run")
    chrome_options.add_argument("--no-service-autorun")
    chrome_options.add_argument("--password-store=basic")
    chrome_options.add_argument("--lang=en-US")
    
    # Enhanced prefs
    prefs = {
        "credentials_enable_service": False,
        "profile.password_manager_enabled": False,
        "profile.default_content_setting_values.notifications": 2,
        "profile.default_content_settings.popups": 0,
        "profile.managed_default_content_settings.images": 2
    }
    chrome_options.add_experimental_option("prefs", prefs)
    
    if headless:
        chrome_options.add_argument("--headless=new")
    else:
        chrome_options.add_argument("--start-maximized")
    
    chrome_options.add_argument("--disable-gpu")
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument("--disable-web-security")
    chrome_options.add_argument("--allow-running-insecure-content")

    driver = webdriver.Chrome(options=chrome_options)
    
    # Advanced stealth JavaScript
    stealth_js = """
        // Remove webdriver traces
        Object.defineProperty(navigator, 'webdriver', {get: () => undefined});
        
        // Mock navigator properties
        Object.defineProperty(navigator, 'languages', {get: () => ['en-US', 'en']});
        Object.defineProperty(navigator, 'plugins', {get: () => [1, 2, 3, 4, 5]});
        Object.defineProperty(navigator, 'platform', {get: () => 'Win32'});
        Object.defineProperty(navigator, 'hardwareConcurrency', {get: () => 4});
        
        // Mock chrome object
        window.chrome = {
            runtime: {},
            loadTimes: function() { return {}; },
            csi: function() { return {}; },
            app: {}
        };
        
        // Override permission queries
        const originalQuery = window.navigator.permissions.query;
        window.navigator.permissions.query = (parameters) => (
            parameters.name === 'notifications' ?
                Promise.resolve({ state: Notification.permission }) :
                originalQuery(parameters)
        );
        
        // Remove automation indicators
        delete window.cdc_adoQpoasnfa76pfcZLmcfl_Array;
        delete window.cdc_adoQpoasnfa76pfcZLmcfl_Promise;
        delete window.cdc_adoQpoasnfa76pfcZLmcfl_Symbol;
        delete window.cdc_adoQpoasnfa76pfcZLmcfl_Object;
    """
    
    driver.execute_script(stealth_js)
    driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {"source": stealth_js})
    
    try:
        # Phase 1: Navigate to YouTube first to establish session
        print("üîÑ Fase 1: Estableciendo sesi√≥n con YouTube...")
        driver.get("https://www.youtube.com")
        time.sleep(3)
        
        # Click sign in button on YouTube
        try:
            sign_in_selectors = [
                (By.CSS_SELECTOR, "a[aria-label*='Sign in']"),
                (By.XPATH, "//a[contains(@href, 'accounts.google.com')]"),
                (By.CSS_SELECTOR, "[href*='accounts.google.com/signin']"),
                (By.XPATH, "//yt-button-renderer//a[contains(@href, 'signin')]")
            ]
            
            sign_in_clicked = False
            for by_type, selector in sign_in_selectors:
                try:
                    sign_in_btn = WebDriverWait(driver, 10).until(
                        EC.element_to_be_clickable((by_type, selector))
                    )
                    driver.execute_script("arguments[0].click();", sign_in_btn)
                    print("‚úÖ Bot√≥n 'Sign In' de YouTube clickeado")
                    sign_in_clicked = True
                    break
                except TimeoutException:
                    continue
            
            if not sign_in_clicked:
                print("‚ö†Ô∏è No se encontr√≥ bot√≥n de Sign In, navegando directamente...")
                driver.get("https://accounts.google.com/signin/v2/identifier?service=youtube&continue=https://www.youtube.com/&hl=en")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Error en bot√≥n Sign In: {e}")
            driver.get("https://accounts.google.com/signin/v2/identifier?service=youtube&continue=https://www.youtube.com/&hl=en")
        
        time.sleep(5)
        
        # Phase 2: Email entry with multiple methods
        print("üîÑ Fase 2: Ingresando email...")
        email_selectors = [
            (By.ID, "identifierId"),
            (By.NAME, "identifier"),
            (By.CSS_SELECTOR, "input[type='email']"),
            (By.XPATH, "//input[@type='email']")
        ]
        
        email_input = None
        for by_type, selector in email_selectors:
            try:
                email_input = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((by_type, selector))
                )
                print(f"‚úÖ Campo de email encontrado: {selector}")
                break
            except TimeoutException:
                continue
        
        if not email_input:
            driver.save_screenshot("debug_no_email_field.png")
            raise Exception("No se pudo encontrar el campo de email")
        
        # Advanced email entry method
        try:
            # Method 1: JavaScript injection
            driver.execute_script("""
                var emailField = arguments[0];
                var email = arguments[1];
                
                emailField.focus();
                emailField.value = '';
                emailField.value = email;
                
                // Trigger all necessary events
                var events = ['input', 'change', 'blur'];
                events.forEach(function(eventType) {
                    var event = new Event(eventType, {bubbles: true, cancelable: true});
                    emailField.dispatchEvent(event);
                });
            """, email_input, email)
            
            print("‚úÖ Email ingresado con JavaScript")
            
        except Exception as e:
            print(f"‚ö†Ô∏è JavaScript fall√≥: {e}, usando m√©todo alternativo...")
            # Fallback method
            email_input.clear()
            ActionChains(driver).click(email_input).pause(0.5).send_keys(email).perform()
        
        time.sleep(2)
        
        # Click Next button
        next_buttons = [
            (By.ID, "identifierNext"),
            (By.CSS_SELECTOR, "[data-test-id='identifierNext']"),
            (By.XPATH, "//span[text()='Next']/../.."),
            (By.XPATH, "//div[@role='button' and .//span[contains(text(), 'Next')]]")
        ]
        
        for by_type, selector in next_buttons:
            try:
                next_button = driver.find_element(by_type, selector)
                driver.execute_script("arguments[0].click();", next_button)
                print("‚úÖ Bot√≥n 'Next' para email clickeado")
                break
            except NoSuchElementException:
                continue
        else:
            email_input.send_keys(Keys.ENTER)
            print("‚ö†Ô∏è Us√© Enter para email")
        
        time.sleep(5)
        
        # Phase 3: Password entry with ultimate method
        print("üîÑ Fase 3: Ingresando contrase√±a...")
        
        # Wait for password field with retries
        password_input = None
        password_selectors = [
            (By.NAME, "password"),
            (By.ID, "password"),
            (By.CSS_SELECTOR, "input[type='password']"),
            (By.XPATH, "//input[@type='password']"),
            (By.XPATH, "//input[@name='Passwd']")
        ]
        
        for attempt in range(5):
            print(f"Intento de contrase√±a {attempt + 1}/5...")
            
            for by_type, selector in password_selectors:
                try:
                    password_input = WebDriverWait(driver, 8).until(
                        EC.presence_of_element_located((by_type, selector))
                    )
                    
                    # Ensure it's interactable
                    WebDriverWait(driver, 5).until(
                        EC.element_to_be_clickable((by_type, selector))
                    )
                    
                    if password_input.is_enabled() and password_input.is_displayed():
                        print(f"‚úÖ Campo de contrase√±a listo: {selector}")
                        break
                    else:
                        password_input = None
                        
                except TimeoutException:
                    continue
            
            if password_input:
                break
                
            if attempt < 4:
                time.sleep(3)
        
        if not password_input:
            # Check for verification challenges
            current_url = driver.current_url.lower()
            if any(word in current_url for word in ['challenge', 'verify', 'captcha']):
                print("üîí Verificaci√≥n de seguridad detectada...")
                if wait_for_human_verification(driver):
                    # Try to continue after verification
                    time.sleep(5)
                    # Look for password field again
                    for by_type, selector in password_selectors:
                        try:
                            password_input = driver.find_element(by_type, selector)
                            if password_input.is_enabled() and password_input.is_displayed():
                                break
                        except:
                            continue
            
            if not password_input:
                driver.save_screenshot("debug_no_password_field.png")
                raise Exception("No se pudo encontrar el campo de contrase√±a despu√©s de m√∫ltiples intentos")
        
        # Ultimate password entry method
        password_success = False
        methods = [
            "javascript_ultimate",
            "action_chains",
            "selenium_basic",
            "character_by_character"
        ]
        
        for method in methods:
            try:
                print(f"üîÑ M√©todo de contrase√±a: {method}")
                
                if method == "javascript_ultimate":
                    driver.execute_script("""
                        var passwordField = arguments[0];
                        var password = arguments[1];
                        
                        // Remove all restrictions
                        passwordField.removeAttribute('readonly');
                        passwordField.removeAttribute('disabled');
                        passwordField.style.pointerEvents = 'auto';
                        passwordField.style.display = 'block';
                        passwordField.style.visibility = 'visible';
                        
                        // Focus and clear
                        passwordField.focus();
                        passwordField.value = '';
                        
                        // Set password
                        passwordField.value = password;
                        
                        // Trigger comprehensive events
                        var events = [
                            'focus', 'click', 'keydown', 'keypress', 'input', 
                            'keyup', 'change', 'blur'
                        ];
                        
                        events.forEach(function(eventType) {
                            var event = new Event(eventType, {
                                bubbles: true, 
                                cancelable: true,
                                view: window
                            });
                            passwordField.dispatchEvent(event);
                        });
                        
                        // Final verification
                        return passwordField.value === password;
                    """, password_input, password)
                    
                elif method == "action_chains":
                    ActionChains(driver).move_to_element(password_input).click().pause(0.5).send_keys(password).perform()
                    
                elif method == "selenium_basic":
                    password_input.clear()
                    password_input.send_keys(password)
                    
                elif method == "character_by_character":
                    password_input.clear()
                    for char in password:
                        password_input.send_keys(char)
                        time.sleep(0.02)
                
                # Verify password was entered
                time.sleep(1)
                entered_value = password_input.get_attribute("value")
                
                if entered_value and len(entered_value) >= len(password) * 0.8:  # Allow some tolerance
                    print(f"‚úÖ Contrase√±a ingresada correctamente con {method}")
                    password_success = True
                    break
                else:
                    print(f"‚ö†Ô∏è {method} fall√≥ - Valor: {len(entered_value) if entered_value else 0} caracteres")
                    
            except Exception as e:
                print(f"‚ö†Ô∏è M√©todo {method} fall√≥: {e}")
                continue
        
        if not password_success:
            print("‚ö†Ô∏è Todos los m√©todos de contrase√±a fallaron, continuando de todos modos...")
        
        time.sleep(2)
        
        # Click password next button
        password_next_buttons = [
            (By.ID, "passwordNext"),
            (By.CSS_SELECTOR, "[data-test-id='passwordNext']"),
            (By.XPATH, "//div[@role='button' and .//span[contains(text(), 'Next')]]"),
            (By.XPATH, "//span[text()='Next']/../..")
        ]
        
        for by_type, selector in password_next_buttons:
            try:
                next_button = driver.find_element(by_type, selector)
                driver.execute_script("arguments[0].click();", next_button)
                print("‚úÖ Bot√≥n 'Next' para contrase√±a clickeado")
                break
            except NoSuchElementException:
                continue
        else:
            password_input.send_keys(Keys.ENTER)
            print("‚ö†Ô∏è Us√© Enter para contrase√±a")
        
        # Phase 4: Handle post-login challenges
        print("üîÑ Fase 4: Manejando verificaciones post-login...")
        
        # Wait for either success or challenge
        start_time = time.time()
        max_wait = 120  # 2 minutes
        
        while time.time() - start_time < max_wait:
            current_url = driver.current_url.lower()
            
            # Success indicators
            if "youtube.com" in current_url or "myaccount.google.com" in current_url:
                print("‚úÖ Login exitoso!")
                break
                
            # Challenge indicators
            if any(word in current_url for word in ['challenge', 'verify', 'captcha']):
                print("üîí Verificaci√≥n adicional requerida...")
                if not headless:
                    print("üë§ Resuelve la verificaci√≥n manualmente en el navegador...")
                    wait_for_human_verification(driver, max_wait=max_wait - int(time.time() - start_time))
                else:
                    print("‚ùå Verificaci√≥n requerida pero modo headless activo")
                    return False
            
            time.sleep(3)
        
        # Phase 5: Navigate to YouTube and collect comprehensive cookies
        print("üîÑ Fase 5: Recolectando cookies de YouTube...")
        
        # Make sure we're on YouTube
        if "youtube.com" not in driver.current_url:
            driver.get("https://www.youtube.com")
            time.sleep(5)
        
        # Navigate to different YouTube pages to collect all possible cookies
        youtube_pages = [
            "https://www.youtube.com/",
            "https://www.youtube.com/feed/subscriptions",
            "https://www.youtube.com/playlist?list=WL",  # Watch Later
            "https://music.youtube.com/"
        ]
        
        for page in youtube_pages:
            try:
                print(f"üìÑ Visitando: {page}")
                driver.get(page)
                time.sleep(3)
            except:
                continue
        
        # Final return to main YouTube page
        driver.get("https://www.youtube.com")
        time.sleep(5)
        
        # Verify we're logged in by looking for user indicators
        try:
            WebDriverWait(driver, 20).until(
                EC.any_of(
                    EC.presence_of_element_located((By.ID, "avatar-btn")),
                    EC.presence_of_element_located((By.CSS_SELECTOR, "[aria-label*='Account menu']")),
                    EC.presence_of_element_located((By.CSS_SELECTOR, "#buttons ytd-topbar-menu-button-renderer")),
                    EC.presence_of_element_located((By.ID, "guide-button"))
                )
            )
            print("‚úÖ Sesi√≥n de YouTube verificada")
        except TimeoutException:
            print("‚ö†Ô∏è No se pudo verificar completamente la sesi√≥n, pero continuando...")
        
        # Save comprehensive cookies
        save_cookies_netscape_format(driver, output_path)
        print(f"‚úÖ Cookies completas guardadas en '{output_path}'")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Error durante el login: {str(e)}")
        try:
            driver.save_screenshot("debug_login_error.png")
            print("üì∏ Screenshot guardada como 'debug_login_error.png'")
        except:
            pass
        return False
        
    finally:
        driver.quit()

def test_cookies_comprehensive(cookie_path: str):
    """
    Prueba exhaustiva de las cookies guardadas
    """
    try:
        # Read cookies
        cookies_dict = {}
        with open(cookie_path, 'r') as f:
            for line in f:
                if line.startswith('#') or not line.strip():
                    continue
                parts = line.strip().split('\t')
                if len(parts) >= 7:
                    domain = parts[0]
                    name = parts[5]
                    value = parts[6]
                    
                    # Only use YouTube cookies for testing
                    if 'youtube' in domain or 'google' in domain:
                        cookies_dict[name] = value
        
        print(f"üîç Probando con {len(cookies_dict)} cookies...")
        
        # Test with multiple YouTube URLs
        test_urls = [
            "https://www.youtube.com/",
            "https://www.youtube.com/feed/subscriptions",
            "https://music.youtube.com/"
        ]
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive'
        }
        
        session = requests.Session()
        session.headers.update(headers)
        
        success_count = 0
        for url in test_urls:
            try:
                response = session.get(url, cookies=cookies_dict, timeout=30)
                
                if response.status_code == 200:
                    # Check for login indicators in response
                    content = response.text.lower()
                    
                    login_indicators = [
                        'ytd-masthead',
                        '"isloggedin":true',
                        '"logged_in":true',
                        'ytInitialData',
                        'account-name'
                    ]
                    
                    if any(indicator in content for indicator in login_indicators):
                        print(f"‚úÖ {url} - Autenticado correctamente")
                        success_count += 1
                    else:
                        print(f"‚ö†Ô∏è {url} - Respuesta recibida pero sin indicadores de login")
                else:
                    print(f"‚ùå {url} - Error HTTP {response.status_code}")
                    
            except Exception as e:
                print(f"‚ùå {url} - Error: {e}")
        
        if success_count >= len(test_urls) * 0.5:  # At least 50% success
            print("‚úÖ Las cookies funcionan correctamente")
            return True
        else:
            print("‚ùå Las cookies no parecen funcionar adecuadamente")
            return False
            
    except Exception as e:
        print(f"‚ùå Error probando cookies: {e}")
        return False

def manual_intervention_mode(email: str, password: str, output_path: str):
    """
    Modo manual mejorado con mejor gu√≠a
    """
    print("üîÑ Iniciando modo de intervenci√≥n manual mejorado...")
    print("üìã Instrucciones detalladas:")
    print("1. Se abrir√° Chrome autom√°ticamente")
    print("2. El script intentar√° completar email y contrase√±a")
    print("3. SI aparece CAPTCHA o 2FA, resu√©lvelo T√ö manualmente")
    print("4. NAVEGA manualmente a diferentes p√°ginas de YouTube:")
    print("   - https://www.youtube.com/")
    print("   - https://www.youtube.com/feed/subscriptions")
    print("   - https://music.youtube.com/")
    print("5. Cuando termines, presiona ENTER aqu√≠")
    
    chrome_options = Options()
    chrome_options.add_argument("--disable-blink-features=AutomationControlled")
    chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
    chrome_options.add_experimental_option('useAutomationExtension', False)
    chrome_options.add_argument("--start-maximized")
    
    driver = webdriver.Chrome(options=chrome_options)
    driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
    
    try:
        # Navigate to YouTube first
        print("üîÑ Navegando a YouTube...")
        driver.get("https://www.youtube.com")
        time.sleep(3)
        
        # Try to click sign in
        try:
            sign_in_btn = driver.find_element(By.CSS_SELECTOR, "a[aria-label*='Sign in']")
            sign_in_btn.click()
            time.sleep(3)
        except:
            driver.get("https://accounts.google.com/signin/v2/identifier?service=youtube&continue=https://www.youtube.com/")
            time.sleep(3)
        
        # Try to fill email
        try:
            email_input = driver.find_element(By.ID, "identifierId")
            email_input.clear()
            email_input.send_keys(email)
            time.sleep(1)
            driver.find_element(By.ID, "identifierNext").click()
            print("‚úÖ Email completado autom√°ticamente")
            time.sleep(5)
            
            # Try to fill password
            try:
                password_input = driver.find_element(By.NAME, "password")
                password_input.clear()
                password_input.send_keys(password)
                time.sleep(1)
                driver.find_element(By.ID, "passwordNext").click()
                print("‚úÖ Contrase√±a completada autom√°ticamente")
            except:
                print("‚ö†Ô∏è Completa la contrase√±a manualmente")
                
        except:
            print("‚ö†Ô∏è Completa el login manualmente")
        
        print("\n" + "="*60)
        print("üë§ INTERVENCI√ìN MANUAL REQUERIDA")
        print("="*60)
        print("üîß Completa cualquier verificaci√≥n que aparezca")
        print("üåê Navega a estas p√°ginas para obtener todas las cookies:")
        print("   1. https://www.youtube.com/")
        print("   2. https://www.youtube.com/feed/subscriptions")
        print("   3. https://music.youtube.com/")
        print("‚è≥ Cuando hayas terminado, presiona ENTER aqu√≠...")
        print("="*60)
        
        input()
        
        # Navigate to collect cookies from current page
        current_url = driver.current_url
        if "youtube.com" not in current_url:
            print("üîÑ Navegando a YouTube para recoger cookies...")
            driver.get("https://www.youtube.com")
            time.sleep(5)
        
        # Save cookies
        save_cookies_netscape_format(driver, output_path)
        print(f"‚úÖ Cookies guardadas en '{output_path}'")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Error en modo manual: {e}")
        return False
    finally:
        driver.quit()

if __name__ == "__main__":
    EMAIL = os.getenv("YOUTUBE_EMAIL")
    PASSWORD = os.getenv("YOUTUBE_PASSWORD")
    OUTPUT_PATH = Path(os.getenv("YOUTUBE_COOKIES_PATH", "app/cookies/cookies.txt"))
    
    if not EMAIL or not PASSWORD:
        print("‚ùå Falta configurar variables de entorno YOUTUBE_EMAIL o YOUTUBE_PASSWORD")
        print("üìù Configura tu archivo .env con:")
        print("   YOUTUBE_EMAIL=tu_email@gmail.com")
        print("   YOUTUBE_PASSWORD=tu_contrase√±a_o_app_password")
        print("   YOUTUBE_COOKIES_PATH=app/cookies/cookies.txt")
        exit(1)
    
    # Create cookies directory if it doesn't exist
    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    
    print("üöÄ YouTube Cookie Extractor - Versi√≥n Definitiva")
    print("="*60)
    print("üéØ Este script obtiene TODAS las cookies necesarias para yt-dlp")
    print("üîê Incluye cookies de YouTube, YouTube Music y Google")
    print("ü§ñ Usa t√©cnicas avanzadas anti-detecci√≥n")
    print("="*60)
    
    print("\nüìã Modos disponibles:")
    print("1. ü§ñ Autom√°tico Avanzado - Usa m√∫ltiples t√©cnicas de evasi√≥n")
    print("2. üë§ Manual Guiado - Te gu√≠a paso a paso para m√°xima efectividad")
    print("3. üîÑ H√≠brido - Intenta autom√°tico, luego manual si falla")
    
    while True:
        mode = input("\nüîß Elige modo (1, 2, 3, o Enter para h√≠brido): ").strip()
        if mode in ['1', '2', '3', '']:
            break
        print("‚ö†Ô∏è Por favor elige 1, 2, 3 o presiona Enter")
    
    success = False
    
    if mode == '1':
        print("\nü§ñ Iniciando modo autom√°tico avanzado...")
        success = comprehensive_youtube_login(EMAIL, PASSWORD, str(OUTPUT_PATH), headless=False)
        
    elif mode == '2':
        print("\nüë§ Iniciando modo manual guiado...")
        success = manual_intervention_mode(EMAIL, PASSWORD, str(OUTPUT_PATH))
        
    else:  # mode == '3' or mode == ''
        print("\nüîÑ Iniciando modo h√≠brido...")
        print("ü§ñ Intentando primero autom√°tico...")
        success = comprehensive_youtube_login(EMAIL, PASSWORD, str(OUTPUT_PATH), headless=False)
        
        if not success:
            print("\n‚ùå Modo autom√°tico fall√≥.")
            retry_manual = input("¬øQuieres intentar modo manual? (Y/n): ").strip().lower()
            if retry_manual != 'n':
                print("\nüë§ Cambiando a modo manual...")
                success = manual_intervention_mode(EMAIL, PASSWORD, str(OUTPUT_PATH))
    
    # Results and testing
    if success:
        print("\n" + "="*60)
        print("üéâ ¬°EXTRACCI√ìN COMPLETADA EXITOSAMENTE!")
        print("="*60)
        
        # Test cookies
        print("\nüîç Probando cookies extra√≠das...")
        test_result = test_cookies_comprehensive(str(OUTPUT_PATH))
        
        if test_result:
            print("\n‚úÖ COOKIES VALIDADAS - Listas para usar")
            print("üöÄ Ahora puedes usar yt-dlp con estas cookies:")
            print(f"   yt-dlp --cookies {OUTPUT_PATH} [URL]")
            
            # Show cookie statistics
            try:
                with open(OUTPUT_PATH, 'r') as f:
                    lines = f.readlines()
                    cookie_lines = [l for l in lines if not l.startswith('#') and l.strip()]
                    youtube_cookies = [l for l in cookie_lines if 'youtube' in l.lower()]
                    google_cookies = [l for l in cookie_lines if 'google' in l.lower()]
                    
                print(f"\nüìä Estad√≠sticas de cookies:")
                print(f"   üìù Total de cookies: {len(cookie_lines)}")
                print(f"   üé• Cookies de YouTube: {len(youtube_cookies)}")
                print(f"   üîç Cookies de Google: {len(google_cookies)}")
                
            except:
                pass
                
        elif test_result is None:
            print("\n‚ö†Ô∏è No se pudieron probar las cookies (falta requests)")
            print("ü§û Pero deber√≠an funcionar con yt-dlp")
            
        else:
            print("\n‚ö†Ô∏è Las cookies pueden no funcionar completamente")
            print("üí° Sugerencias:")
            print("   - Intenta el modo manual si usaste autom√°tico")
            print("   - Verifica que tienes acceso completo a YouTube")
            print("   - Considera usar una contrase√±a de aplicaci√≥n")
    
    else:
        print("\n" + "="*60)
        print("‚ùå EXTRACCI√ìN FALL√ì")
        print("="*60)
        print("\nüîß Soluciones recomendadas:")
        print("1. üîë Usa una contrase√±a de aplicaci√≥n:")
        print("   - Ve a tu cuenta de Google")
        print("   - Seguridad ‚Üí Verificaci√≥n en 2 pasos ‚Üí Contrase√±as de aplicaciones")
        print("   - Genera una contrase√±a espec√≠fica para esta aplicaci√≥n")
        
        print("\n2. ‚öôÔ∏è Configuraci√≥n de cuenta:")
        print("   - Desactiva temporalmente la verificaci√≥n en 2 pasos")
        print("   - Aseg√∫rate de que tu cuenta no est√© bloqueada")
        
        print("\n3. üåê M√©todo manual alternativo:")
        print("   - Usa la extensi√≥n 'Get cookies.txt LOCALLY' en Chrome")
        print("   - Inicia sesi√≥n en YouTube manualmente")
        print("   - Exporta las cookies directamente")
        
        print("\n4. üêõ Debug:")
        print("   - Revisa las screenshots generadas")
        print("   - Verifica tu conexi√≥n a internet")
        print("   - Intenta desde una IP diferente")
    
    print(f"\nüìÅ Archivo de cookies: {OUTPUT_PATH}")
    print("üîö Proceso terminado.")